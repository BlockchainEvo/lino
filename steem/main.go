package main

import (
	// Stdlib
	"fmt"
	"io/ioutil"
    "net/http"
    "strings"
    "strconv"
	"encoding/json"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/tendermint/go-crypto/keys"
	"gopkg.in/redis.v3"
	"os"
	crypto "github.com/tendermint/go-crypto"
	ctypes "github.com/tendermint/tendermint/rpc/core/types"
	rpcclient "github.com/tendermint/tendermint/rpc/client"
	ttx "github.com/lino-network/lino/types/tx"
	btypes "github.com/lino-network/lino/types"
	atypes "github.com/tendermint/abci/types"
)

const (
	TxTypeVote = "vote"
	TxTypeComment = "comment"
	TxTypeAccountCreate = "account_create"
	TxTypeCostomJson = "custom_json"
	TxTypeTransfer = "transfer"

	ChainID = "lino"

	ctypeFollow = "follow"
)

func getBlock(height uint) map[string]interface{}{
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	body := strings.NewReader(fmt.Sprintf(`{"jsonrpc": "2.0", "method": "get_block", "params": [%v], "id": "1"}`, height))
	req, err := http.NewRequest("POST", "https://api.steemit.com", body)
	if err != nil {
		// handle err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()
    buf, _ := ioutil.ReadAll(resp.Body)
    var result map[string]interface{}
    json.Unmarshal(buf, &result)
	return result
}



// [transfer map[memo:{"type":"withdrawal",
// "tx_id":"9E4C41C575722676CD64EA9AF33F89CCDF5AC91C534452051F80473680AAE145",
// "id":"01aeea430000000f"} from:steemiex to:rcl amount:1.563 STEEM]]

func printTxType(height uint, client *redis.Client) {
	if height % 100 == 0 {
		fmt.Println(height)
	}
	res := getBlock(height)
	r, ok := res["result"].(map[string]interface{})
	if !ok {
		return
	}
	txs, ok := r["transactions"].([]interface{})
	if !ok {
		return
	}
	for _, tx := range txs {
		txMp, ok := tx.(map[string]interface{})
		if !ok {
			return
		}
		ops, ok := txMp["operations"].([]interface{})
		if !ok {
			return
		}

		for _, op := range ops {
			opList, ok := op.([]interface{})
			if !ok {
				return
			}
			switch opList[0].(string){
			case TxTypeAccountCreate:
				sendAccountCreateTx(opList[1].(map[string]interface{}), client)
			case TxTypeComment:
				sendPostTx(opList[1].(map[string]interface{}), client)
			case TxTypeCostomJson:
				costomJson(opList[1].(map[string]interface{}), client)
			case TxTypeVote:
				sendVoteTx(opList[1].(map[string]interface{}), client)
			default:
			}
		}
	}
}


// [vote map[author:pfunk permlink:smart-money-rebranding-cryptocurrency-for-mass-appeal
// weight:10000 voter:pirates]]

func sendVoteTx(ops map[string]interface{}, client *redis.Client) error {
	voter, ok := ops["voter"].(string)
	if !ok {
		return nil
	}
	author, ok := ops["author"].(string)
	if !ok {
		return nil
	}

	privKey, err := GetOrSetPrivKey(voter, client)
	if err != nil {
		return err
	}

	seq, err := client.Get(ops["permlink"].(string)).Result()
	if err != nil {
		return err
	}

	seqNo, err := strconv.Atoi(seq)
	if err != nil {
		log.Error().Err(err).Msgf("Lino Redis: Post AtoI failed")
		return err
	}
	tx := new(ttx.LikeTx)
	tx.From = btypes.AccountName([]byte(voter))
	tx.To = btypes.GetPostID(btypes.GetAccountNameFromString(author), seqNo)
	tx.Weight = int(ops["weight"].(float64))

	// Wrap and add signer
	likeTx := &ttx.CliLikeTx{
		ChainID: ChainID,
		Tx:      tx,
	}

	bres, err := SignAndBroadcast(likeTx, *privKey)
	if err == nil && bres.CheckTx.Code == atypes.CodeType_OK {
		log.Debug().Msgf("voter %v votes %v with seq %v, weight: %v", voter, author, seqNo, tx.Weight)
	}
	fmt.Println(bres)
	return nil
}

// [custom_json map[required_auths:[]
// required_posting_auths:[tincho] id:follow
// json:["follow",{"follower":"tincho","following":"walden","what":[]}]]]

func costomJson(ops map[string]interface{}, client *redis.Client) error {
	log.Debug().Msgf("costom Json: %v", ops)
	costomizeOp, ok := ops["json"].([]interface{})
	if !ok {
		return nil
	}
	switch costomizeOp[0] {
	case ctypeFollow:
		followMp := costomizeOp[1].(map[string]interface{})
		return sendFollowTx(followMp, client)
	default:
		log.Debug().Msgf("ctype unrecognized: %v", costomizeOp[0])
	}
	return nil
}

func sendFollowTx(ops map[string]interface{}, client *redis.Client) error {
	follower, ok := ops["follower"].(string)
	if !ok {
		return nil
	}
	following, ok := ops["following"].(string)
	if !ok {
		return nil
	}

	privKey, err := GetOrSetPrivKey(follower, client)
	if err != nil {
		return err
	}

	tx := new(ttx.FollowTx)
	tx.Follower = btypes.GetAccountNameFromString(follower)
	tx.Following = btypes.GetAccountNameFromString(following)
	tx.IsFollow = true

	followTx := &ttx.CliFollowTx{
		ChainID: ChainID,
		Tx:      tx,
	}
	bres, err := SignAndBroadcast(followTx, *privKey)
	if err != nil {
		log.Error().Err(err).Msgf("send account create failed")
		return err
	}
	if err == nil && bres.CheckTx.Code == atypes.CodeType_OK {
		log.Debug().Msgf("%v follow %v", follower, following)
	}
	fmt.Println(bres)
	return nil
}

// [account_create
// 	map[posting:map[key_auths:[[STM5f7TvYJkaPzRNRYDGcqeeihp4Re36D3dVow5dR6fq8t7LJ5njM 1]]
// 		weight_threshold:1 account_auths:[]]
// 		memo_key:STM7qutcubp3gchumeP1TYDn6PjjuEa5e65woKUH2snWPWEH6YJ9F
// 		json_metadata: fee:35.000 STEEM creator:steem
//      new_account_name:milyarder
// 		owner:map[weight_threshold:1 account_auths:[]
// 		key_auths:[[STM8RGnpimxHN9qZhc51qXAUDKYdBmeaMfojZRAqzjQuPqsEtXJEz 1]]]
// 		active:map[weight_threshold:1 account_auths:[]
// 		key_auths:[[STM6h11pmn159Um2w89Vnu18zz1dRzwbPCXB41ES5xnT1N8RGkYCA 1]]]
// 		]
// ]

func sendAccountCreateTx(ops map[string]interface{}, client *redis.Client) error {
	accountName, ok := ops["new_account_name"].(string)
	if !ok {
		return nil
	}
	_, err := GetOrSetPrivKey(accountName, client)
	if err != nil {
		return err
	}
	return nil
}

func sendRegisterTx(username string, privKey crypto.PrivKeyEd25519) error {
	tx := new(ttx.RegisterTx)
	tx.Username = btypes.GetAccountNameFromString(username)
	tx.PubKey = privKey.PubKey()

	registerTx := &ttx.CliRegisterTx{
		ChainID: ChainID,
		Tx:      tx,
	}

	bres, err := SignAndBroadcast(registerTx, privKey)
	if err != nil {
		log.Error().Err(err).Msgf("send account create failed")
		return err
	}
	if err == nil && bres.CheckTx.Code == atypes.CodeType_OK {
		fmt.Println("register username:", username)
	}
	fmt.Println(bres)
	return nil
}

func sendRegisterTxWithNode(username string, privKey crypto.PrivKeyEd25519, node *rpcclient.HTTP) error {
	tx := new(ttx.RegisterTx)
	tx.Username = btypes.GetAccountNameFromString(username)
	tx.PubKey = privKey.PubKey()

	registerTx := &ttx.CliRegisterTx{
		ChainID: ChainID,
		Tx:      tx,
	}

	bres, err := SignAndBroadcastWithNode(registerTx, privKey, node)
	if err != nil {
		log.Error().Err(err).Msgf("send account create failed")
		return err
	}
	if err == nil && bres.CheckTx.Code == atypes.CodeType_OK {
		// fmt.Println("register username:", username)
	}
	// fmt.Println(bres)
	return nil
}

// [comment map[json_metadata:{"tags":["hi"],"app":"steemit/0.1"} parent_author:justinashby
// parent_permlink:re-prettykitten-re-sagittarian-re-prettykitten-i-m-new-20170312t054954875z
// author:prettykitten
// permlink:re-justinashby-re-prettykitten-re-sagittarian-re-prettykitten-i-m-new-20170312t055033370z
// title: body:OK.]]


func sendPostTx(ops map[string]interface{}, client *redis.Client) error {
	log.Debug().Msgf("Process ops type: %s", ops)
	author, ok := ops["author"].(string)
	if !ok {
		return nil
	}
	parentAuthor, ok := ops["parent_author"].(string)
	if !ok {
		return nil
	}

	parentPermlink, ok := ops["parent_permlink"].(string)
	if !ok {
		return nil
	}

	privKey, err := GetOrSetPrivKey(author, client)
	if err != nil {
		return err
	}

	// load data
	seq, err := client.Get(author + "#seq").Result()
	if err == redis.Nil {
		seq = "0"
	}
	seqNo, err := strconv.Atoi(seq)
	if err != nil {
		log.Error().Err(err).Msgf("Lino Redis: Post AtoI failed")
		return err
	}
	tx := new(ttx.PostTx)
	tx.Author = btypes.AccountName([]byte(author))
	tx.Title = ops["title"].(string)
	tx.Content = ops["body"].(string)
	tx.Sequence = seqNo + 1
	if parentAuthor != "" {
		seqStr, err := client.Get(parentPermlink).Result()
		if err == redis.Nil {
			log.Error().Err(err).Msgf("Parent Perm link doesn't exist")
			return nil
		} else if err != nil {
			panic(err)
		}

		parentSeq, err := strconv.Atoi(seqStr)
		if err != nil {
			return err
		}
		tx.Parent = btypes.GetPostID(btypes.GetAccountNameFromString(parentAuthor), parentSeq)
	}

	// Wrap and add signer
	postTx := &ttx.CliPostTx{
		ChainID: ChainID,
		Tx:      tx,
	}

	bres, err := SignAndBroadcast(postTx, *privKey)
	if err == nil && bres.CheckTx.Code == atypes.CodeType_OK {
		if err := client.Set(author+"#seq", strconv.Itoa(seqNo+1), 0).Err(); err != nil {
			return err
		}
		if err := client.Set(ops["permlink"].(string), strconv.Itoa(seqNo+1), 0).Err(); err != nil {
			return err
		}
		if parentAuthor != "" {
			fmt.Println("comment:", author, seqNo + 1)
		} else {
			fmt.Println("post:", author, seqNo + 1)
		}
	}

	fmt.Println(bres)
	return nil
}

	
func SignAndBroadcast(tx keys.Signable, privKey crypto.PrivKeyEd25519) (*ctypes.ResultBroadcastTxCommit, error) {
	sbytes := tx.SignBytes()
	tx.Sign(privKey.PubKey(), privKey.Sign(sbytes))

	_, err := tx.TxBytes()
	if err != nil {
		return nil, err
	}
	//return node.BroadcastTxCommit(pkg)
	return nil, err
}

func SignAndBroadcastWithNode(tx keys.Signable, privKey crypto.PrivKeyEd25519, node *rpcclient.HTTP) (*ctypes.ResultBroadcastTxCommit, error) {
	sbytes := tx.SignBytes()
	tx.Sign(privKey.PubKey(), privKey.Sign(sbytes))

	pkg, err := tx.TxBytes()
	if err != nil {
		return nil, err
	}
	return node.BroadcastTxCommit(pkg)
}

func GetOrSetPrivKey(username string, client *redis.Client) (*crypto.PrivKeyEd25519, error) {
	privKeyStr, err := client.Get(username).Result()
	if err == redis.Nil {
		privKey := crypto.GenPrivKeyEd25519()
		privKeyBytes, err := json.Marshal(privKey)
		if err != nil {
			return nil, err
		}
		if err := sendRegisterTx(username, privKey); err != nil {
		 	return nil, err
		}
		if err := client.Set(username, string(privKeyBytes), 0).Err(); err != nil {
			return nil, err
		}
		return &privKey, nil
	} else if err != nil {
		panic(err)
	}
	var privKey crypto.PrivKeyEd25519
	if json.Unmarshal([]byte(privKeyStr), &privKey); err != nil {
		return nil, err
	}
	return &privKey, err
}
var valList = [8]string{"52.156.165.226:46657","20.188.7.127:46657","52.174.154.12:46657","191.232.39.67:46657","52.158.235.117:46657","52.158.238.189:46657","52.158.239.200:46657","52.158.239.67:46657"}
func singleThread(startIndex, interval int, redisClient *redis.Client, done chan bool) {
	var node = rpcclient.NewHTTP(valList[(startIndex/interval)%len(valList)], "/websocket")
	for i := startIndex; i < startIndex + interval; i++ {
		privKey := crypto.GenPrivKeyEd25519()
		sendRegisterTxWithNode("username"+strconv.Itoa(i), privKey, node)
	}
	done <- true
}

func main() {
	env := os.Getenv("GO_ENV")
	var configFileName string

    done := make(chan bool)
	switch env {
	case "production":
		configFileName = "chain_config_prod"
	case "development", "":
		configFileName = "chain_config"
	}
	log.Debug().Msgf("Loading config file: %s", configFileName)
	viper.SetConfigName(configFileName)
	viper.AddConfigPath(".")
	if err := viper.ReadInConfig(); err != nil {
		log.Fatal().Err(err).Msg("Fatal error config file")
	}

	// temporarily we need to store priv key and pub key in redis.
	redisClient := redis.NewClient(&redis.Options{
		Addr:     viper.GetString("chain_redis_host") + ":" + viper.GetString("chain_redis_port"),
		Password: viper.GetString("chain_redis_password"),
		DB:       viper.GetInt64("chain_redis_db"),
	})
	for i := 0; i < viper.GetInt("thread_number"); i ++ {
		go singleThread(viper.GetInt("start_index") + i * viper.GetInt("interval"), viper.GetInt("interval"), redisClient, done)
	}
	for i := 0; i < viper.GetInt("thread_number"); i ++ {
		<- done
	}


}